"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[775],{8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var s=i(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},9718:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"module2/physics_properties","title":"Physics Properties: Gravity, Collisions, and More","description":"Introduction","source":"@site/docs/module2/physics_properties.md","sourceDirName":"module2","slug":"/module2/physics_properties","permalink":"/humanoid-robotics-book/docs/module2/physics_properties","draft":false,"unlisted":false,"editUrl":"https://github.com/Amnaahmed798/humanoid-robotics-book/edit/main/docs/module2/physics_properties.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Module 2: Digital Twin (Gazebo & Unity)","permalink":"/humanoid-robotics-book/docs/module2/introduction"},"next":{"title":"Integration of ROS 2 with Simulated Environments","permalink":"/humanoid-robotics-book/docs/module2/ros2_sim_integration"}}');var t=i(4848),r=i(8453);const o={},l="Physics Properties: Gravity, Collisions, and More",c={},a=[{value:"Introduction",id:"introduction",level:2},{value:"Gravity in Gazebo",id:"gravity-in-gazebo",level:2},{value:"Setting Global Gravity",id:"setting-global-gravity",level:3},{value:"Gravity Considerations",id:"gravity-considerations",level:3},{value:"Collision Properties",id:"collision-properties",level:2},{value:"Collision Detection",id:"collision-detection",level:3},{value:"Collision Geometry Types",id:"collision-geometry-types",level:3},{value:"Inertial Properties",id:"inertial-properties",level:2},{value:"Mass and Center of Mass",id:"mass-and-center-of-mass",level:3},{value:"Calculating Inertial Properties",id:"calculating-inertial-properties",level:3},{value:"Friction Models",id:"friction-models",level:2},{value:"ODE (Open Dynamics Engine) Friction",id:"ode-open-dynamics-engine-friction",level:3},{value:"Typical Friction Coefficients",id:"typical-friction-coefficients",level:3},{value:"Bounce and Restitution",id:"bounce-and-restitution",level:2},{value:"Restitution Coefficient",id:"restitution-coefficient",level:3},{value:"Contact Properties",id:"contact-properties",level:2},{value:"Contact Stiffness and Damping",id:"contact-stiffness-and-damping",level:3},{value:"Physics Performance Tuning",id:"physics-performance-tuning",level:2},{value:"Time Step and Iterations",id:"time-step-and-iterations",level:3},{value:"Robot-Specific Physics Considerations",id:"robot-specific-physics-considerations",level:2},{value:"Joint Dynamics",id:"joint-dynamics",level:3},{value:"Actuator Simulation",id:"actuator-simulation",level:3},{value:"Troubleshooting Physics Issues",id:"troubleshooting-physics-issues",level:2},{value:"Common Problems and Solutions",id:"common-problems-and-solutions",level:3},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"physics-properties-gravity-collisions-and-more",children:"Physics Properties: Gravity, Collisions, and More"})}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"Understanding physics properties is crucial for creating realistic robot simulations in Gazebo. This chapter covers the fundamental physics concepts that govern how robots and objects behave in simulation, including gravity, collisions, friction, and other physical properties that affect robot motion and interaction."}),"\n",(0,t.jsx)(n.h2,{id:"gravity-in-gazebo",children:"Gravity in Gazebo"}),"\n",(0,t.jsx)(n.h3,{id:"setting-global-gravity",children:"Setting Global Gravity"}),"\n",(0,t.jsx)(n.p,{children:"Gravity is defined globally for each world and affects all objects in the simulation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<sdf version="1.7">\n  <world name="my_world">\n    \x3c!-- Set gravity vector (x, y, z) in m/s^2 --\x3e\n    <gravity>0 0 -9.8</gravity>\n    \x3c!-- ... rest of world definition --\x3e\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"gravity-considerations",children:"Gravity Considerations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Standard Earth gravity: 9.8 m/s\xb2 downward (0 0 -9.8)"}),"\n",(0,t.jsx)(n.li,{children:"Different celestial bodies have different gravity values"}),"\n",(0,t.jsx)(n.li,{children:"Zero gravity can be useful for testing floating robots"}),"\n",(0,t.jsx)(n.li,{children:'Direction matters: negative Z is typically "down"'}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"collision-properties",children:"Collision Properties"}),"\n",(0,t.jsx)(n.h3,{id:"collision-detection",children:"Collision Detection"}),"\n",(0,t.jsx)(n.p,{children:"Collision properties define how objects interact when they come into contact:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<link name="link_name">\n  <collision name="collision_name">\n    <geometry>\n      <box>\n        <size>1 1 1</size>\n      </box>\n    </geometry>\n    \x3c!-- Surface properties --\x3e\n    <surface>\n      <friction>\n        <ode>\n          <mu>1.0</mu>\n          <mu2>1.0</mu2>\n        </ode>\n      </friction>\n      <bounce>\n        <restitution_coefficient>0.1</restitution_coefficient>\n        <threshold>100000</threshold>\n      </bounce>\n      <contact>\n        <ode>\n          <kp>1e+16</kp>\n          <kd>1e+13</kd>\n          <max_vel>100.0</max_vel>\n          <min_depth>0.001</min_depth>\n        </ode>\n      </contact>\n    </surface>\n  </collision>\n</link>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"collision-geometry-types",children:"Collision Geometry Types"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Box"}),": Rectangular prism"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cylinder"}),": Cylindrical shape"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sphere"}),": Spherical shape"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mesh"}),": Complex shapes from 3D models"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Plane"}),": Infinite flat surface"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"inertial-properties",children:"Inertial Properties"}),"\n",(0,t.jsx)(n.h3,{id:"mass-and-center-of-mass",children:"Mass and Center of Mass"}),"\n",(0,t.jsx)(n.p,{children:"Inertial properties determine how objects respond to forces:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<link name="link_name">\n  <inertial>\n    \x3c!-- Mass in kilograms --\x3e\n    <mass>1.0</mass>\n    \x3c!-- Center of mass offset --\x3e\n    <pose>0.1 0 0 0 0 0</pose>\n    \x3c!-- Inertia matrix --\x3e\n    <inertia>\n      <ixx>0.083</ixx>\n      <ixy>0</ixy>\n      <ixz>0</ixz>\n      <iyy>0.083</iyy>\n      <iyz>0</iyz>\n      <izz>0.167</izz>\n    </inertia>\n  </inertial>\n</link>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"calculating-inertial-properties",children:"Calculating Inertial Properties"}),"\n",(0,t.jsx)(n.p,{children:"For common shapes with uniform density \u03c1:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Box"})," (width w, depth d, height h):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Mass: m = \u03c1 \xd7 w \xd7 d \xd7 h"}),"\n",(0,t.jsx)(n.li,{children:"Ixx = (1/12) \xd7 m \xd7 (d\xb2 + h\xb2)"}),"\n",(0,t.jsx)(n.li,{children:"Iyy = (1/12) \xd7 m \xd7 (w\xb2 + h\xb2)"}),"\n",(0,t.jsx)(n.li,{children:"Izz = (1/12) \xd7 m \xd7 (w\xb2 + d\xb2)"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Cylinder"})," (radius r, height h):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Mass: m = \u03c1 \xd7 \u03c0 \xd7 r\xb2 \xd7 h"}),"\n",(0,t.jsx)(n.li,{children:"Ixx = Iyy = (1/12) \xd7 m \xd7 (3r\xb2 + h\xb2)"}),"\n",(0,t.jsx)(n.li,{children:"Izz = (1/2) \xd7 m \xd7 r\xb2"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Sphere"})," (radius r):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Mass: m = \u03c1 \xd7 (4/3) \xd7 \u03c0 \xd7 r\xb3"}),"\n",(0,t.jsx)(n.li,{children:"Ixx = Iyy = Izz = (2/5) \xd7 m \xd7 r\xb2"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"friction-models",children:"Friction Models"}),"\n",(0,t.jsx)(n.h3,{id:"ode-open-dynamics-engine-friction",children:"ODE (Open Dynamics Engine) Friction"}),"\n",(0,t.jsx)(n.p,{children:"Gazebo uses ODE for physics simulation. Friction parameters include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"\u03bc (mu)"}),": Primary friction coefficient (longitudinal)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"\u03bc\u2082 (mu2)"}),": Secondary friction coefficient (lateral)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"slip1"}),": Inverse of longitudinal slip"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"slip2"}),": Inverse of lateral slip"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"<surface>\n  <friction>\n    <ode>\n      <mu>0.5</mu>\n      <mu2>0.5</mu2>\n      <slip1>0</slip1>\n      <slip2>0</slip2>\n    </ode>\n  </friction>\n</surface>\n"})}),"\n",(0,t.jsx)(n.h3,{id:"typical-friction-coefficients",children:"Typical Friction Coefficients"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Material Combination"}),(0,t.jsx)(n.th,{children:"Static Friction \u03bc"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Rubber on dry concrete"}),(0,t.jsx)(n.td,{children:"1.0"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Steel on steel"}),(0,t.jsx)(n.td,{children:"0.74"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Wood on wood"}),(0,t.jsx)(n.td,{children:"0.25 - 0.5"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Ice on ice"}),(0,t.jsx)(n.td,{children:"0.1"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Teflon on Teflon"}),(0,t.jsx)(n.td,{children:"0.04"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"bounce-and-restitution",children:"Bounce and Restitution"}),"\n",(0,t.jsx)(n.h3,{id:"restitution-coefficient",children:"Restitution Coefficient"}),"\n",(0,t.jsx)(n.p,{children:'The restitution coefficient determines how "bouncy" collisions are:'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"<surface>\n  <bounce>\n    \x3c!-- 0.0 = no bounce (perfectly inelastic) --\x3e\n    \x3c!-- 1.0 = perfect bounce (elastic) --\x3e\n    <restitution_coefficient>0.2</restitution_coefficient>\n    \x3c!-- Energy threshold for bounce --\x3e\n    <threshold>100000</threshold>\n  </bounce>\n</surface>\n"})}),"\n",(0,t.jsx)(n.h2,{id:"contact-properties",children:"Contact Properties"}),"\n",(0,t.jsx)(n.h3,{id:"contact-stiffness-and-damping",children:"Contact Stiffness and Damping"}),"\n",(0,t.jsx)(n.p,{children:"Contact properties determine how objects respond when they touch:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"<surface>\n  <contact>\n    <ode>\n      \x3c!-- Spring stiffness (penetration resistance) --\x3e\n      <kp>1e+16</kp>\n      \x3c!-- Damping coefficient --\x3e\n      <kd>1e+13</kd>\n      \x3c!-- Maximum contact penetration velocity --\x3e\n      <max_vel>100.0</max_vel>\n      \x3c!-- Minimum contact depth --\x3e\n      <min_depth>0.001</min_depth>\n    </ode>\n  </contact>\n</surface>\n"})}),"\n",(0,t.jsx)(n.h2,{id:"physics-performance-tuning",children:"Physics Performance Tuning"}),"\n",(0,t.jsx)(n.h3,{id:"time-step-and-iterations",children:"Time Step and Iterations"}),"\n",(0,t.jsx)(n.p,{children:"Adjust physics parameters for simulation stability vs. performance:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<world name="my_world">\n  <physics type="ode">\n    \x3c!-- Physics engine parameters --\x3e\n    <max_step_size>0.001</max_step_size>  \x3c!-- Time step (smaller = more accurate) --\x3e\n    <real_time_factor>1.0</real_time_factor>  \x3c!-- Target simulation speed --\x3e\n    <real_time_update_rate>1000</real_time_update_rate>  \x3c!-- Hz --\x3e\n    <ode>\n      \x3c!-- Solver iterations (more = more stable but slower) --\x3e\n      <solver>\n        <type>quick</type>\n        <iters>100</iters>\n        <sor>1.3</sor>\n      </solver>\n      \x3c!-- Constraint parameters --\x3e\n      <constraints>\n        <cfm>0.0</cfm>\n        <erp>0.2</erp>\n        <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n        <contact_surface_layer>0.001</contact_surface_layer>\n      </constraints>\n    </ode>\n  </physics>\n</world>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"robot-specific-physics-considerations",children:"Robot-Specific Physics Considerations"}),"\n",(0,t.jsx)(n.h3,{id:"joint-dynamics",children:"Joint Dynamics"}),"\n",(0,t.jsx)(n.p,{children:"For realistic joint behavior, include dynamic properties:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<joint name="joint_name" type="revolute">\n  <parent>parent_link</parent>\n  <child>child_link</child>\n  <axis>\n    <xyz>0 0 1</xyz>\n    <dynamics>\n      \x3c!-- Damping coefficient --\x3e\n      <damping>0.1</damping>\n      \x3c!-- Friction coefficient --\x3e\n      <friction>0.0</friction>\n      \x3c!-- Spring stiffness --\x3e\n      <spring_reference>0.0</spring_reference>\n      <spring_stiffness>0.0</spring_stiffness>\n    </dynamics>\n    <limit>\n      <lower>-1.57</lower>\n      <upper>1.57</upper>\n      <effort>100</effort>\n      <velocity>1</velocity>\n    </limit>\n  </axis>\n</joint>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"actuator-simulation",children:"Actuator Simulation"}),"\n",(0,t.jsx)(n.p,{children:"Simulate actuator behavior with realistic dynamics:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<gazebo reference="joint_name">\n  <provideFeedback>true</provideFeedback>\n  <joint_properties>\n    <ode_joint_config>\n      <fudge_factor>1.0</fudge_factor>\n      <cfm_damping>1</cfm_damping>\n      <implicit_spring_damper>1</implicit_spring_damper>\n    </ode_joint_config>\n  </joint_properties>\n</gazebo>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"troubleshooting-physics-issues",children:"Troubleshooting Physics Issues"}),"\n",(0,t.jsx)(n.h3,{id:"common-problems-and-solutions",children:"Common Problems and Solutions"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Objects falling through surfaces"}),": Increase contact stiffness (kp) or decrease min_depth"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unstable simulations"}),": Reduce time step or increase solver iterations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Objects sliding unrealistically"}),": Increase friction coefficients"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Objects bouncing too much"}),": Decrease restitution coefficient"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Robot joints acting stiffly"}),": Adjust joint damping values"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use realistic values"}),": Base physics parameters on real-world measurements"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Start conservative"}),": Use stable values first, then optimize for performance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test incrementally"}),": Add physics properties one at a time"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validate with reality"}),": Compare simulation behavior with real robots when possible"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Document parameters"}),": Keep a record of physics values used for reproducibility"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consider computational cost"}),": Balance accuracy with simulation performance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use appropriate geometry"}),": Match collision geometry to visual geometry for consistency"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);