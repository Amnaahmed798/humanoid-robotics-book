"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[103],{8215:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module2/ros2_sim_integration","title":"Integration of ROS 2 with Simulated Environments","description":"Introduction","source":"@site/docs/module2/ros2_sim_integration.md","sourceDirName":"module2","slug":"/module2/ros2_sim_integration","permalink":"/humanoid-robotics-book/docs/module2/ros2_sim_integration","draft":false,"unlisted":false,"editUrl":"https://github.com/Amnaahmed798/humanoid-robotics-book/edit/main/docs/module2/ros2_sim_integration.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Physics Properties: Gravity, Collisions, and More","permalink":"/humanoid-robotics-book/docs/module2/physics_properties"},"next":{"title":"Sensor Simulation: LiDAR, Depth Cameras, IMUs","permalink":"/humanoid-robotics-book/docs/module2/sensor_simulation"}}');var i=t(4848),s=t(8453);const r={},a="Integration of ROS 2 with Simulated Environments",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Gazebo-ROS 2 Bridge",id:"gazebo-ros-2-bridge",level:2},{value:"Installation and Setup",id:"installation-and-setup",level:3},{value:"Key Components",id:"key-components",level:3},{value:"Launching Gazebo with ROS 2 Integration",id:"launching-gazebo-with-ros-2-integration",level:2},{value:"Basic Launch File",id:"basic-launch-file",level:3},{value:"Advanced Launch Configuration",id:"advanced-launch-configuration",level:3},{value:"Controlling Robots in Simulation",id:"controlling-robots-in-simulation",level:2},{value:"Joint State Publisher",id:"joint-state-publisher",level:3},{value:"Controller Manager Integration",id:"controller-manager-integration",level:3},{value:"Sensor Integration",id:"sensor-integration",level:2},{value:"Publishing Sensor Data from Simulation",id:"publishing-sensor-data-from-simulation",level:3},{value:"Receiving Sensor Data in ROS 2",id:"receiving-sensor-data-in-ros-2",level:3},{value:"Robot Control in Simulation",id:"robot-control-in-simulation",level:2},{value:"Velocity Control",id:"velocity-control",level:3},{value:"Joint Position Control",id:"joint-position-control",level:3},{value:"Advanced Simulation Techniques",id:"advanced-simulation-techniques",level:2},{value:"Custom Gazebo Plugins",id:"custom-gazebo-plugins",level:3},{value:"Simulation State Management",id:"simulation-state-management",level:3},{value:"Testing and Validation",id:"testing-and-validation",level:2},{value:"Automated Testing in Simulation",id:"automated-testing-in-simulation",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Simulation Performance",id:"simulation-performance",level:3},{value:"Realism vs. Performance",id:"realism-vs-performance",level:3},{value:"Development Workflow",id:"development-workflow",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"integration-of-ros-2-with-simulated-environments",children:"Integration of ROS 2 with Simulated Environments"})}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(n.p,{children:"Integrating ROS 2 with simulation environments like Gazebo is fundamental to modern robotics development. This integration allows developers to test algorithms, validate robot behaviors, and train AI models in safe, controlled virtual environments before deploying to physical hardware. This chapter covers the essential techniques and best practices for connecting ROS 2 with simulation environments."}),"\n",(0,i.jsx)(n.h2,{id:"gazebo-ros-2-bridge",children:"Gazebo-ROS 2 Bridge"}),"\n",(0,i.jsx)(n.h3,{id:"installation-and-setup",children:"Installation and Setup"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"gazebo_ros_pkgs"})," package provides the bridge between Gazebo and ROS 2:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Install Gazebo ROS packages for your ROS 2 distribution\nsudo apt update\nsudo apt install ros-humble-gazebo-ros-pkgs ros-humble-gazebo-plugins\n"})}),"\n",(0,i.jsx)(n.h3,{id:"key-components",children:"Key Components"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"gazebo_ros"}),": Core ROS 2 interface for Gazebo"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"gazebo_ros_pkgs"}),": Collection of ROS 2 plugins for Gazebo"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"gazebo_plugins"}),": Gazebo-specific plugins with ROS 2 interfaces"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"launching-gazebo-with-ros-2-integration",children:"Launching Gazebo with ROS 2 Integration"}),"\n",(0,i.jsx)(n.h3,{id:"basic-launch-file",children:"Basic Launch File"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Launch Gazebo with ROS 2 interface\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_ros'),\n                'launch',\n                'empty_world.launch.py'\n            ])\n        ])\n    )\n\n    # Optional: Add a robot to the simulation\n    spawn_entity = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=[\n            '-entity', 'my_robot',\n            '-file', '/path/to/robot.urdf',\n            '-x', '0', '-y', '0', '-z', '0.5'\n        ],\n        output='screen'\n    )\n\n    return LaunchDescription([\n        gazebo,\n        spawn_entity\n    ])\n"})}),"\n",(0,i.jsx)(n.h3,{id:"advanced-launch-configuration",children:"Advanced Launch Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.conditions import IfCondition\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Declare launch arguments\n    world = DeclareLaunchArgument(\n        'world',\n        default_value='empty',\n        description='Choose one of the world files from `/path/to/worlds`'\n    )\n\n    headless = DeclareLaunchArgument(\n        'headless',\n        default_value='false',\n        description='Whether to execute gzclient'\n    )\n\n    # Include Gazebo launch with parameters\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_ros'),\n                'launch',\n                'gazebo.launch.py'\n            ])\n        ]),\n        launch_arguments={\n            'world': LaunchConfiguration('world'),\n            'gui': LaunchConfiguration('headless')\n        }.items()\n    )\n\n    return LaunchDescription([\n        world,\n        headless,\n        gazebo\n    ])\n"})}),"\n",(0,i.jsx)(n.h2,{id:"controlling-robots-in-simulation",children:"Controlling Robots in Simulation"}),"\n",(0,i.jsx)(n.h3,{id:"joint-state-publisher",children:"Joint State Publisher"}),"\n",(0,i.jsx)(n.p,{children:"The joint state publisher bridges the gap between simulated joint states and ROS 2:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'\x3c!-- In your URDF/robot file --\x3e\n<xacro:macro name="joint_state_publisher" params="robot_description">\n  <node name="robot_state_publisher" pkg="robot_state_publisher" exec="robot_state_publisher">\n    <param name="robot_description" value="$(var robot_description)"/>\n  </node>\n</xacro:macro>\n'})}),"\n",(0,i.jsx)(n.h3,{id:"controller-manager-integration",children:"Controller Manager Integration"}),"\n",(0,i.jsx)(n.p,{children:"For more complex robots, use the controller manager:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# config/my_robot_controllers.yaml\ncontroller_manager:\n  ros__parameters:\n    update_rate: 100  # Hz\n\n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n\n    velocity_controller:\n      type: velocity_controllers/JointGroupVelocityController\n\n    position_controller:\n      type: position_controllers/JointGroupPositionController\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Launch file for controllers\nfrom launch import LaunchDescription\nfrom launch.actions import RegisterEventHandler\nfrom launch.event_handlers import OnProcessStart\nfrom launch.substitutions import PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Controller manager\n    controller_manager = Node(\n        package='controller_manager',\n        executable='ros2_control_node',\n        parameters=[\n            PathJoinSubstitution([\n                FindPackageShare('my_robot_description'),\n                'config',\n                'my_robot_controllers.yaml'\n            ])\n        ],\n        remappings=[\n            ('/joint_states', 'joint_states'),\n        ]\n    )\n\n    # Load controllers after controller manager starts\n    load_joint_state_broadcaster = ExecuteProcess(\n        cmd=['ros2', 'control', 'load_controller', '--set-state', 'active',\n             'joint_state_broadcaster'],\n        output='screen'\n    )\n\n    load_velocity_controller = ExecuteProcess(\n        cmd=['ros2', 'control', 'load_controller', '--set-state', 'active',\n             'velocity_controller'],\n        output='screen'\n    )\n\n    return LaunchDescription([\n        controller_manager,\n        RegisterEventHandler(\n            OnProcessStart(\n                target_action=controller_manager,\n                on_start=[\n                    load_joint_state_broadcaster,\n                    load_velocity_controller,\n                ]\n            )\n        )\n    ])\n"})}),"\n",(0,i.jsx)(n.h2,{id:"sensor-integration",children:"Sensor Integration"}),"\n",(0,i.jsx)(n.h3,{id:"publishing-sensor-data-from-simulation",children:"Publishing Sensor Data from Simulation"}),"\n",(0,i.jsx)(n.p,{children:"Gazebo plugins publish sensor data to ROS 2 topics:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Example: IMU sensor in URDF with Gazebo plugin --\x3e\n<gazebo reference="imu_link">\n  <sensor name="imu_sensor" type="imu">\n    <always_on>true</always_on>\n    <update_rate>100</update_rate>\n    <plugin name="imu_plugin" filename="libgazebo_ros_imu.so">\n      <ros>\n        <namespace>/my_robot</namespace>\n        <remapping>~/out:=imu/data</remapping>\n      </ros>\n      <frame_name>imu_link</frame_name>\n      <body_name>imu_link</body_name>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,i.jsx)(n.h3,{id:"receiving-sensor-data-in-ros-2",children:"Receiving Sensor Data in ROS 2"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan, Imu, JointState\nfrom geometry_msgs.msg import Twist\nimport numpy as np\n\nclass SimulationSensorProcessor(Node):\n    def __init__(self):\n        super().__init__('simulation_sensor_processor')\n\n        # Subscribe to various simulated sensors\n        self.lidar_subscription = self.create_subscription(\n            LaserScan,\n            '/my_robot/laser_scan',\n            self.lidar_callback,\n            10\n        )\n\n        self.imu_subscription = self.create_subscription(\n            Imu,\n            '/my_robot/imu/data',\n            self.imu_callback,\n            10\n        )\n\n        self.joint_subscription = self.create_subscription(\n            JointState,\n            '/my_robot/joint_states',\n            self.joint_callback,\n            10\n        )\n\n        # Publisher for robot commands\n        self.cmd_vel_publisher = self.create_publisher(\n            Twist,\n            '/my_robot/cmd_vel',\n            10\n        )\n\n        self.get_logger().info('Simulation sensor processor initialized')\n\n    def lidar_callback(self, msg):\n        # Process LiDAR data from simulation\n        ranges = np.array(msg.ranges)\n        valid_ranges = ranges[np.isfinite(ranges)]\n\n        if len(valid_ranges) > 0:\n            min_distance = np.min(valid_ranges)\n\n            # Simple obstacle avoidance\n            if min_distance < 1.0:  # If obstacle within 1 meter\n                self.avoid_obstacle()\n\n    def imu_callback(self, msg):\n        # Process IMU data from simulation\n        orientation = msg.orientation\n        angular_velocity = msg.angular_velocity\n        linear_acceleration = msg.linear_acceleration\n\n        # Use IMU data for balance control, navigation, etc.\n        self.process_imu_data(orientation, angular_velocity, linear_acceleration)\n\n    def joint_callback(self, msg):\n        # Process joint state data from simulation\n        for i, name in enumerate(msg.name):\n            position = msg.position[i] if i < len(msg.position) else 0.0\n            velocity = msg.velocity[i] if i < len(msg.velocity) else 0.0\n            effort = msg.effort[i] if i < len(msg.effort) else 0.0\n\n            # Process individual joint data\n            self.process_joint_data(name, position, velocity, effort)\n\n    def avoid_obstacle(self):\n        # Simple obstacle avoidance behavior\n        twist = Twist()\n        twist.linear.x = 0.0  # Stop forward motion\n        twist.angular.z = 1.0  # Turn right\n        self.cmd_vel_publisher.publish(twist)\n\n    def process_imu_data(self, orientation, angular_velocity, linear_acceleration):\n        # Implement IMU-based processing\n        pass\n\n    def process_joint_data(self, joint_name, position, velocity, effort):\n        # Implement joint-specific processing\n        pass\n"})}),"\n",(0,i.jsx)(n.h2,{id:"robot-control-in-simulation",children:"Robot Control in Simulation"}),"\n",(0,i.jsx)(n.h3,{id:"velocity-control",children:"Velocity Control"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from geometry_msgs.msg import Twist\n\nclass VelocityController(Node):\n    def __init__(self):\n        super().__init__('velocity_controller')\n\n        self.cmd_vel_publisher = self.create_publisher(\n            Twist,\n            '/my_robot/cmd_vel',\n            10\n        )\n\n        self.timer = self.create_timer(0.1, self.control_loop)\n\n    def control_loop(self):\n        # Implement your control algorithm\n        twist = Twist()\n        twist.linear.x = 0.5  # Move forward at 0.5 m/s\n        twist.angular.z = 0.2  # Turn at 0.2 rad/s\n        self.cmd_vel_publisher.publish(twist)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"joint-position-control",children:"Joint Position Control"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from std_msgs.msg import Float64MultiArray\n\nclass JointPositionController(Node):\n    def __init__(self):\n        super().__init__('joint_position_controller')\n\n        self.joint_cmd_publisher = self.create_publisher(\n            Float64MultiArray,\n            '/my_robot/joint_group_position_controller/commands',\n            10\n        )\n\n        self.timer = self.create_timer(0.01, self.control_loop)\n\n    def control_loop(self):\n        # Send joint position commands\n        cmd = Float64MultiArray()\n        cmd.data = [0.5, -0.3, 0.8]  # Joint positions in radians\n        self.joint_cmd_publisher.publish(cmd)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-simulation-techniques",children:"Advanced Simulation Techniques"}),"\n",(0,i.jsx)(n.h3,{id:"custom-gazebo-plugins",children:"Custom Gazebo Plugins"}),"\n",(0,i.jsx)(n.p,{children:"For specialized simulation needs, you can create custom Gazebo plugins:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// custom_robot_plugin.cpp\n#include <gazebo/gazebo.hh>\n#include <gazebo/physics/physics.hh>\n#include <gazebo/common/common.hh>\n#include <ros/ros.h>\n#include <std_msgs/Float64.h>\n\nnamespace gazebo\n{\n  class CustomRobotPlugin : public ModelPlugin\n  {\n    public: void Load(physics::ModelPtr _parent, sdf::ElementPtr /*_sdf*/)\n    {\n      // Store the model pointer for convenience\n      this->model = _parent;\n\n      // Initialize ROS\n      if (!ros::isInitialized())\n      {\n        int argc = 0;\n        char **argv = NULL;\n        ros::init(argc, argv, "gazebo_custom_robot", ros::init_options::NoSigintHandler);\n      }\n\n      // Create ROS node handle\n      this->rosNode.reset(new ros::NodeHandle("gazebo_custom_robot"));\n\n      // Subscribe to command topic\n      ros::SubscribeOptions so =\n        ros::SubscribeOptions::create<std_msgs::Float64>(\n            "/" + this->model->GetName() + "/cmd_throttle",\n            1,\n            boost::bind(&CustomRobotPlugin::OnRosMsg, this, _1),\n            ros::VoidPtr(), &this->rosQueue);\n      this->rosSub = this->rosNode->subscribe(so);\n\n      // Spin up the queue helper thread\n      this->callbackQueueThread =\n        std::thread(std::bind(&CustomRobotPlugin::QueueThread, this));\n    }\n\n    // Callback function for ROS subscription\n    private: void OnRosMsg(const std_msgs::Float64ConstPtr &_msg)\n    {\n      std::lock_guard<std::mutex> lock(this->mutex);\n      this->throttleCmd = _msg->data;\n    }\n\n    // ROS helper thread\n    private: void QueueThread()\n    {\n      static const double timeout = 0.01;\n      while (this->rosNode->ok())\n      {\n        this->rosQueue.callAvailable(ros::WallDuration(timeout));\n      }\n    }\n\n    private: physics::ModelPtr model;\n    private: std::unique_ptr<ros::NodeHandle> rosNode;\n    private: ros::Subscriber rosSub;\n    private: ros::CallbackQueue rosQueue;\n    private: std::thread callbackQueueThread;\n    private: double throttleCmd;\n    private: std::mutex mutex;\n  };\n\n  // Register this plugin with the simulator\n  GZ_REGISTER_MODEL_PLUGIN(CustomRobotPlugin)\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"simulation-state-management",children:"Simulation State Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from gazebo_msgs.srv import GetEntityState, SetEntityState\nfrom gazebo_msgs.msg import ModelState\nfrom geometry_msgs.msg import Pose, Twist\n\nclass SimulationStateManager(Node):\n    def __init__(self):\n        super().__init__('simulation_state_manager')\n\n        # Create service clients\n        self.get_state_client = self.create_client(\n            GetEntityState,\n            '/gazebo/get_entity_state'\n        )\n\n        self.set_state_client = self.create_client(\n            SetEntityState,\n            '/gazebo/set_entity_state'\n        )\n\n        # Wait for services\n        while not self.get_state_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Get entity state service not available, waiting again...')\n\n        while not self.set_state_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Set entity state service not available, waiting again...')\n\n    def get_robot_state(self, entity_name='my_robot', relative_entity_name=''):\n        request = GetEntityState.Request()\n        request.name = entity_name\n        request.relative_entity_name = relative_entity_name\n\n        future = self.get_state_client.call_async(request)\n        rclpy.spin_until_future_complete(self, future)\n\n        if future.result() is not None:\n            response = future.result()\n            return response.state\n        else:\n            self.get_logger().error('Failed to get entity state')\n            return None\n\n    def set_robot_state(self, entity_name, pose, twist):\n        request = SetEntityState.Request()\n        request.state = ModelState()\n        request.state.model_name = entity_name\n        request.state.pose = pose\n        request.state.twist = twist\n        request.state.reference_frame = 'world'\n\n        future = self.set_state_client.call_async(request)\n        rclpy.spin_until_future_complete(self, future)\n\n        if future.result() is not None:\n            return future.result().success\n        else:\n            self.get_logger().error('Failed to set entity state')\n            return False\n"})}),"\n",(0,i.jsx)(n.h2,{id:"testing-and-validation",children:"Testing and Validation"}),"\n",(0,i.jsx)(n.h3,{id:"automated-testing-in-simulation",children:"Automated Testing in Simulation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import unittest\nimport rclpy\nfrom rclpy.executors import SingleThreadedExecutor\nfrom std_msgs.msg import String\nfrom geometry_msgs.msg import Twist\nfrom sensor_msgs.msg import LaserScan\n\nclass TestSimulationIntegration(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        rclpy.init()\n\n    @classmethod\n    def tearDownClass(cls):\n        rclpy.shutdown()\n\n    def setUp(self):\n        self.node = rclpy.create_node(\'test_simulation_integration\')\n        self.executor = SingleThreadedExecutor()\n        self.executor.add_node(self.node)\n\n        # Create publisher and subscriber for testing\n        self.cmd_publisher = self.node.create_publisher(\n            Twist, \'/test_robot/cmd_vel\', 10\n        )\n\n        self.feedback_subscription = self.node.create_subscription(\n            String, \'/test_feedback\', self.feedback_callback, 10\n        )\n\n        self.feedback_received = None\n\n    def feedback_callback(self, msg):\n        self.feedback_received = msg.data\n\n    def test_basic_movement(self):\n        """Test that robot can move in simulation."""\n        # Send a movement command\n        twist = Twist()\n        twist.linear.x = 1.0\n        self.cmd_publisher.publish(twist)\n\n        # Wait for feedback\n        timeout = 0\n        while self.feedback_received is None and timeout < 100:\n            self.executor.spin_once(timeout_sec=0.1)\n            timeout += 1\n\n        self.assertIsNotNone(self.feedback_received)\n        self.assertIn(\'moving\', self.feedback_received.lower())\n\n    def test_sensor_data(self):\n        """Test that sensor data is published correctly."""\n        sensor_subscription = self.node.create_subscription(\n            LaserScan, \'/test_robot/laser_scan\', self.sensor_callback, 10\n        )\n        self.sensor_data_received = None\n\n        timeout = 0\n        while self.sensor_data_received is None and timeout < 100:\n            self.executor.spin_once(timeout_sec=0.1)\n            timeout += 1\n\n        self.assertIsNotNone(self.sensor_data_received)\n        self.assertGreater(len(self.sensor_data_received.ranges), 0)\n\n    def sensor_callback(self, msg):\n        self.sensor_data_received = msg\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"simulation-performance",children:"Simulation Performance"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Physics Parameters"}),": Tune physics parameters for performance vs. accuracy"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Update Rates"}),": Match simulation update rates to algorithm requirements"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simplification"}),": Use simplified models for real-time applications"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Threading"}),": Use appropriate threading for ROS communication"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Resource Management"}),": Monitor CPU and memory usage"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"realism-vs-performance",children:"Realism vs. Performance"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Sensor Noise"}),": Include realistic noise models for robust algorithms"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Latency"}),": Simulate communication delays when appropriate"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Approximation"}),": Balance model complexity with simulation speed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Validation"}),": Compare simulation results with real-world data"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Iterative Improvement"}),": Start simple and add complexity gradually"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"development-workflow",children:"Development Workflow"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Modular Design"}),": Create modular launch files for different scenarios"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parameterization"}),": Use launch arguments for flexible configurations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Version Control"}),": Keep simulation worlds and models under version control"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Documentation"}),": Document simulation assumptions and limitations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Testing"}),": Implement automated tests for simulation scenarios"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"TF Tree"}),": Verify TF tree is properly connected between ROS and Gazebo"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Timing"}),": Check for timing issues between ROS nodes and simulation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Coordinate Systems"}),": Ensure consistent coordinate system conventions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Resource Limits"}),": Monitor and adjust resource limits for complex simulations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Plugin Issues"}),": Verify Gazebo plugins are properly configured and loaded"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The integration of ROS 2 with simulation environments enables rapid development, testing, and validation of robotic systems before deployment to physical hardware."})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(6540);const i={},s=o.createContext(i);function r(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);