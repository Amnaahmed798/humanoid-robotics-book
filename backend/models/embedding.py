from pydantic import BaseModel, validator
from typing import List, Optional
from datetime import datetime


class EmbeddingVector(BaseModel):
    """
    Numerical representation of text content generated by the Cohere model.
    """
    id: Optional[str] = None
    vector: List[float]  # The embedding vector (1024-dimensional for multilingual-v3.0)
    chunk_id: Optional[str] = None  # Reference to the associated text chunk (optional for query embeddings)
    model_name: str = "embed-multilingual-v3.0"  # Default model name
    model_version: str = "3.0"  # Default model version
    created_at: datetime = datetime.now()

    class Config:
        # Allow extra fields during development
        extra = "allow"

    @validator('vector')
    def validate_vector_dimensions(cls, v):
        """Validate that vector has exactly 1024 dimensions (for multilingual model)"""
        if len(v) != 1024:
            raise ValueError(f'Vector must have exactly 1024 dimensions, got {len(v)}')
        # Validate that all values are floats
        if not all(isinstance(val, (int, float)) for val in v):
            raise ValueError('All vector values must be numeric')
        return v

    @validator('model_name')
    def validate_model_name(cls, v):
        """Validate that model_name is a valid Cohere model identifier"""
        valid_models = [
            "embed-multilingual-v3.0",
            "embed-english-v3.0",
            "embed-multilingual-light-v3.0",
            "embed-english-light-v3.0"
        ]
        if v not in valid_models:
            raise ValueError(f'model_name must be one of {valid_models}')
        return v

    @validator('chunk_id')
    def validate_chunk_id(cls, v):
        """Validate that chunk_id is not empty when provided"""
        if v is not None and (not v or v.strip() == ""):
            raise ValueError('chunk_id cannot be empty')
        return v

    def __str__(self):
        return f"EmbeddingVector(id={self.id}, model={self.model_name}, dimensions={len(self.vector)})"

    def __repr__(self):
        return self.__str__()


class QdrantCollection(BaseModel):
    """
    Container for embeddings with cosine distance metric, designed for similarity search operations.
    """
    name: str
    vector_size: int = 1024  # Default for Cohere multilingual model
    distance_metric: str = "Cosine"  # Default distance metric
    point_count: int = 0
    created_at: datetime = datetime.now()

    @validator('vector_size')
    def validate_vector_size(cls, v):
        """Validate that vector_size matches the embedding model dimensions"""
        if v != 1024:
            # Note: While we default to 1024 for Cohere multilingual, other models might have different sizes
            # For now, we'll allow flexibility but warn about the default
            print(f"Warning: Vector size is {v}, but Cohere multilingual model typically uses 1024")
        return v

    @validator('distance_metric')
    def validate_distance_metric(cls, v):
        """Validate that distance_metric is one of the allowed values"""
        valid_metrics = ["Cosine", "Euclidean", "Dot"]
        if v not in valid_metrics:
            raise ValueError(f'distance_metric must be one of {valid_metrics}')
        return v.lower().capitalize()  # Normalize to capitalized form

    @validator('name')
    def validate_name(cls, v):
        """Validate that name is not empty and follows Qdrant naming conventions"""
        if not v or v.strip() == "":
            raise ValueError('Collection name cannot be empty')
        # Qdrant collection names should match: ^[a-zA-Z0-9][a-zA-Z0-9_-]*$
        import re
        if not re.match(r'^[a-zA-Z0-9][a-zA-Z0-9_-]*$', v):
            raise ValueError('Collection name must start with alphanumeric and contain only alphanumeric, underscore, and hyphen')
        return v

    def __str__(self):
        return f"QdrantCollection(name={self.name}, size={self.vector_size}, metric={self.distance_metric})"

    def __repr__(self):
        return self.__str__()